<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenQuantify AI-Enhanced IDE</title>
    <style>
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="ide-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <h2>🌐 OpenQuantify AI IDE</h2>
            <input type="text" id="projectName" placeholder="Project Name" class="prompt-input" style="width: 200px; margin: 0;">
            <button class="btn" onclick="saveProject()">💾 Save</button>
            <button class="btn btn-secondary" onclick="loadProject()">📂 Load</button>
            <button class="btn" onclick="runCode()">▶️ Run</button>
            <button class="btn" onclick="deployProject()">🚀 Deploy</button>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Development Boards -->
            <div class="section">
                <h3>🔧 Development Boards</h3>
                <div class="device-grid">
                    <div class="device-card" onclick="selectBoard('arduino')" data-board="arduino">
                        <div>🔲 Arduino</div>
                        <small>Uno R3</small>
                    </div>
                    <div class="device-card" onclick="selectBoard('raspberry')" data-board="raspberry">
                        <div>🍓 Raspberry Pi</div>
                        <small>4 Model B</small>
                    </div>
                    <div class="device-card" onclick="selectBoard('esp32')" data-board="esp32">
                        <div>📡 ESP32</div>
                        <small>WiFi + BT</small>
                    </div>
                    <div class="device-card" onclick="selectBoard('jetson')" data-board="jetson">
                        <div>🧠 Jetson Nano</div>
                        <small>AI Computing</small>
                    </div>
                </div>
            </div>

            <!-- Sensors -->
            <div class="section">
                <h3>📊 Sensors</h3>
                <div class="sensor-list">
                    <div class="sensor-item" onclick="toggleSensor('temperature')">
                        <span>🌡️ Temperature</span>
                        <div class="sensor-status" id="temp-status"></div>
                    </div>
                    <div class="sensor-item" onclick="toggleSensor('motion')">
                        <span>🏃 Motion</span>
                        <div class="sensor-status" id="motion-status"></div>
                    </div>
                    <div class="sensor-item" onclick="toggleSensor('light')">
                        <span>💡 Light</span>
                        <div class="sensor-status" id="light-status"></div>
                    </div>
                    <div class="sensor-item" onclick="toggleSensor('humidity')">
                        <span>💧 Humidity</span>
                        <div class="sensor-status" id="humidity-status"></div>
                    </div>
                    <div class="sensor-item" onclick="toggleSensor('gyroscope')">
                        <span>🔄 Gyroscope</span>
                        <div class="sensor-status" id="gyro-status"></div>
                    </div>
                </div>
            </div>

            <!-- Mesh Objects -->
            <div class="section">
                <h3>🎲 3D Objects</h3>
                <div class="ai-tools-grid">
                    <button class="ai-tool-btn" onclick="addMesh('cube')">📦 Cube</button>
                    <button class="ai-tool-btn" onclick="addMesh('sphere')">⚪ Sphere</button>
                    <button class="ai-tool-btn" onclick="addMesh('cylinder')">🥫 Cylinder</button>
                    <button class="ai-tool-btn" onclick="addMesh('torus')">🍩 Torus</button>
                </div>
            </div>
        </div>

        <!-- Editor -->
        <div class="editor-container">
            <div id="editor"></div>
        </div>

        <!-- 3D Preview -->
        <div class="preview-container">
            <div class="mesh-controls">
                <button class="mesh-btn" onclick="resetCamera()">🎯 Reset View</button>
                <button class="mesh-btn" onclick="toggleWireframe()">🕸️ Wireframe</button>
                <button class="mesh-btn" onclick="togglePhysics()">⚡ Physics</button>
            </div>
            <canvas id="meshCanvas"></canvas>
        </div>

        <!-- AI Panel -->
        <div class="ai-panel">
            <div class="section">
                <h3>🤖 AI Assistant</h3>
                <input type="text" id="aiPrompt" placeholder="Describe what you want to code or create..." class="prompt-input">
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn" onclick="generateCode()">🧠 Generate Code</button>
                    <button class="btn btn-secondary" onclick="explainCode()">📝 Explain Code</button>
                    <button class="btn btn-secondary" onclick="optimizeCode()">⚡ Optimize</button>
                </div>
                
                <div class="ai-tools-grid">
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Add gravity physics')">🌍 Add Gravity</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Make object draggable')">👆 Draggable</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Add click animation')">✨ Animate</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Add particle system')">🎆 Particles</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Add lighting effects')">💡 Lighting</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Create camera controls')">📷 Camera</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Add collision detection')">💥 Collision</button>
                    <button class="ai-tool-btn" onclick="insertAIPrompt('Generate random objects')">🎲 Random</button>
                </div>
                
                <div id="aiResponse" class="ai-response" style="display: none;">
                    <div id="responseContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let editor;
        let scene, camera, renderer, controls;
        let selectedBoard = null;
        let connectedSensors = new Set();
        let meshObjects = [];
        let physicsEnabled = false;
        let wireframeMode = false;

        // Initialize Monaco Editor
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }});
        require(['vs/editor/editor.main'], function () {
            editor = monaco.editor.create(document.getElementById('editor'), {
                value: `// OpenQuantify AI-Enhanced IDE
// Start coding with AI assistance!

// Example: Create a rotating cube with physics
function createRotatingCube() {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshPhongMaterial({ color: 0x4CAF50 });
    const cube = new THREE.Mesh(geometry, material);
    
    scene.add(cube);
    
    // Add rotation animation
    function animate() {
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
        requestAnimationFrame(animate);
    }
    animate();
    
    return cube;
}

// AI-generated code will appear here...`,
                language: 'javascript',
                theme: 'vs-dark',
                fontSize: 14,
                wordWrap: 'on',
                minimap: { enabled: false },
                scrollBeyondLastLine: false
            });

            // Auto-save functionality
            editor.onDidChangeModelContent(() => {
                clearTimeout(window.autoSaveTimeout);
                window.autoSaveTimeout = setTimeout(autoSave, 2000);
            });
        });

        // Initialize Three.js Scene
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('meshCanvas'), antialias: true });
            renderer.setSize(600, 400);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add grid
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);

            // Mouse controls simulation
            let mouseX = 0, mouseY = 0;
            document.getElementById('meshCanvas').addEventListener('mousemove', (event) => {
                const rect = event.target.getBoundingClientRect();
                mouseX = (event.clientX - rect.left) / rect.width * 2 - 1;
                mouseY = -(event.clientY - rect.top) / rect.height * 2 + 1;
            });

            animate3D();
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            
            // Update physics if enabled
            if (physicsEnabled) {
                updatePhysics();
            }
            
            renderer.render(scene, camera);
        }

        // Board Selection
        function selectBoard(boardType) {
            // Remove previous selection
            document.querySelectorAll('.device-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Select new board
            const selectedCard = document.querySelector(`[data-board="${boardType}"]`);
            selectedCard.classList.add('selected');
            selectedBoard = boardType;
            
            // Generate board-specific code
            generateBoardCode(boardType);
        }

        function generateBoardCode(boardType) {
            const boardTemplates = {
                arduino: `// Arduino Uno R3 Setup
void setup() {
    Serial.begin(9600);
    // Initialize your sensors here
}

void loop() {
    // Main loop code
    delay(100);
}`,
                raspberry: `# Raspberry Pi 4 Setup
import RPi.GPIO as GPIO
import time

GPIO.setmode(GPIO.BCM)
# Setup your GPIO pins here

try:
    while True:
        # Main loop
        time.sleep(0.1)
except KeyboardInterrupt:
    GPIO.cleanup()`,
                esp32: `// ESP32 Setup with WiFi
#include <WiFi.h>

const char* ssid = "your_wifi";
const char* password = "your_password";

void setup() {
    Serial.begin(115200);
    WiFi.begin(ssid, password);
    
    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.println("Connecting to WiFi...");
    }
}

void loop() {
    // Your IoT code here
    delay(1000);
}`,
                jetson: `# Jetson Nano AI Setup
import cv2
import numpy as np
import tensorflow as tf

# Initialize camera
cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()
    if ret:
        # AI processing here
        cv2.imshow('AI Vision', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

cap.release()
cv2.destroyAllWindows()`
            };

            if (boardTemplates[boardType]) {
                editor.setValue(boardTemplates[boardType]);
            }
        }

        // Sensor Management
        function toggleSensor(sensorType) {
            const statusElement = document.getElementById(`${sensorType.replace('gyroscope', 'gyro')}-status`);
            
            if (connectedSensors.has(sensorType)) {
                connectedSensors.delete(sensorType);
                statusElement.classList.remove('connected');
            } else {
                connectedSensors.add(sensorType);
                statusElement.classList.add('connected');
                generateSensorCode(sensorType);
            }
        }

        function generateSensorCode(sensorType) {
            const sensorCode = {
                temperature: `// Temperature Sensor Integration
const temperatureSensor = {
    pin: 'A0',
    read: function() {
        return Math.random() * 30 + 20; // Simulated reading
    },
    onUpdate: function(callback) {
        setInterval(() => {
            callback(this.read());
        }, 1000);
    }
};

temperatureSensor.onUpdate((temp) => {
    console.log('Temperature:', temp + '°C');
    // Update your 3D visualization here
});`,
                motion: `// Motion Sensor Integration
const motionSensor = {
    pin: 'D2',
    detected: false,
    onMotion: function(callback) {
        // Simulate motion detection
        setInterval(() => {
            this.detected = Math.random() > 0.8;
            if (this.detected) callback();
        }, 2000);
    }
};

motionSensor.onMotion(() => {
    console.log('Motion detected!');
    // Trigger animation or alert
});`,
                light: `// Light Sensor Integration
const lightSensor = {
    pin: 'A1',
    read: function() {
        return Math.random() * 1024; // 10-bit ADC value
    },
    getPercentage: function() {
        return (this.read() / 1024) * 100;
    }
};

setInterval(() => {
    const lightLevel = lightSensor.getPercentage();
    console.log('Light level:', lightLevel + '%');
    // Adjust scene lighting based on sensor
}, 1000);`
            };

            if (sensorCode[sensorType]) {
                const currentCode = editor.getValue();
                editor.setValue(currentCode + '\n\n' + sensorCode[sensorType]);
            }
        }

        // Mesh Management
        function addMesh(type) {
            let geometry, material, mesh;
            
            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.5, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(0.7, 0.2, 16, 100);
                    break;
            }
            
            material = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                wireframe: wireframeMode
            });
            mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(
                (Math.random() - 0.5) * 4,
                Math.random() * 2,
                (Math.random() - 0.5) * 4
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            scene.add(mesh);
            meshObjects.push(mesh);
            
            // Generate code for the mesh
            generateMeshCode(type, mesh);
        }

        function generateMeshCode(type, mesh) {
            const meshCode = `
// Added ${type} mesh
const ${type}Geometry = new THREE.${type === 'cube' ? 'Box' : type.charAt(0).toUpperCase() + type.slice(1)}Geometry(${
    type === 'cube' ? '1, 1, 1' :
    type === 'sphere' ? '0.5, 32, 32' :
    type === 'cylinder' ? '0.5, 0.5, 1, 32' :
    '0.7, 0.2, 16, 100'
});
const ${type}Material = new THREE.MeshPhongMaterial({ color: 0x${mesh.material.color.getHexString()} });
const ${type}Mesh = new THREE.Mesh(${type}Geometry, ${type}Material);
${type}Mesh.position.set(${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)});
scene.add(${type}Mesh);`;

            const currentCode = editor.getValue();
            editor.setValue(currentCode + meshCode);
        }

        // AI Integration
        function insertAIPrompt(prompt) {
            document.getElementById('aiPrompt').value = prompt;
            generateCode();
        }

        async function generateCode() {
            const prompt = document.getElementById('aiPrompt').value.trim();
            if (!prompt) return;

            showAIResponse('Generating code...');
            
            try {
                const response = await fetch('/generate-js', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt,
                        context: {
                            selectedBoard,
                            connectedSensors: Array.from(connectedSensors),
                            currentCode: editor.getValue()
                        }
                    })
                });
                
                const data = await response.json();
                
                if (data.code) {
                    // Insert generated code into editor
                    const currentCode = editor.getValue();
                    editor.setValue(currentCode + '\n\n// AI Generated Code\n' + data.code);
                    showAIResponse('Code generated successfully!');
                    
                    // Execute if it's for 3D scene
                    if (prompt.toLowerCase().includes('3d') || prompt.toLowerCase().includes('mesh') ||
                        prompt.toLowerCase().includes('physics') || prompt.toLowerCase().includes('animation')) {
                        try {
                            eval(data.code);
                        } catch (e) {
                            console.error('Error executing generated code:', e);
                        }
                    }
                } else {
                    showAIResponse('Error: ' + (data.error || 'Failed to generate code'));
                }
            } catch (error) {
                showAIResponse('Network error: ' + error.message);
            }
        }

        async function explainCode() {
            const selectedText = editor.getModel().getValueInRange(editor.getSelection());
            const codeToExplain = selectedText || editor.getValue();
            
            showAIResponse('Analyzing code...');
            
            try {
                const response = await fetch('/explain-code', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: codeToExplain })
                });
                
                const data = await response.json();
                showAIResponse(data.explanation || 'No explanation available.');
            } catch (error) {
                showAIResponse('Error explaining code: ' + error.message);
            }
        }

        async function optimizeCode() {
            const codeToOptimize = editor.getValue();
            
            showAIResponse('Optimizing code...');
            
            try {
                const response = await fetch('/optimize-code', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: codeToOptimize })
                });
                
                const data = await response.json();
                
                if (data.optimized_code) {
                    editor.setValue(data.optimized_code);
                    showAIResponse('Code optimized successfully!');
                } else {
                    showAIResponse('Optimization suggestions: ' + (data.suggestions || 'No optimizations found.'));
                }
            } catch (error) {
                showAIResponse('Error optimizing code: ' + error.message);
            }
        }

        function showAIResponse(message) {
            const responseDiv = document.getElementById('aiResponse');
            const contentDiv = document.getElementById('responseContent');
            
            contentDiv.innerHTML = message;
            responseDiv.style.display = 'block';
            
            setTimeout(() => {
                if (message.includes('successfully') || message.includes('Error') || message.includes('Network error')) {
                    responseDiv.style.display = 'none';
                }
            }, 5000);
        }

        // 3D Controls
        function resetCamera() {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            meshObjects.forEach(mesh => {
                mesh.material.wireframe = wireframeMode;
            });
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            if (physicsEnabled) {
                initPhysics();
            }
        }

        function initPhysics() {
            // Simple physics simulation
            meshObjects.forEach(mesh => {
                if (!mesh.velocity) {
                    mesh.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        -0.01,
                        (Math.random() - 0.5) * 0.02
                    );
                }
            });
        }

        function updatePhysics() {
            meshObjects.forEach(mesh => {
                if (mesh.velocity) {
                    mesh.position.add(mesh.velocity);
                    
                    // Simple ground collision
                    if (mesh.position.y < 0.5) {
                        mesh.position.y = 0.5;
                        mesh.velocity.y = Math.abs(mesh.velocity.y) * 0.8;
                    }
                    
                    // Walls
                    if (Math.abs(mesh.position.x) > 5) {
                        mesh.velocity.x *= -0.8;
                    }
                    if (Math.abs(mesh.position.z) > 5) {
                        mesh.velocity.z *= -0.8;
                    }
                    
                    // Apply gravity
                    mesh.velocity.y -= 0.001;
                }
            });
        }

        // Project Management
        async function saveProject() {
            const projectData = {
                name: document.getElementById('projectName').value || 'Untitled',
                code: editor.getValue(),
                selectedBoard,
                connectedSensors: Array.from(connectedSensors),
                meshObjects: meshObjects.map(mesh => ({
                    type: mesh.geometry.type,
                    position: mesh.position.toArray(),
                    rotation: mesh.rotation.toArray(),
                    color: mesh.material.color.getHex()
                })),
                scene: scene.toJSON()
            };
            
            try {
                const response = await fetch('/save-project', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectData)
                });
                
                const result = await response.json();
                if (result.success) {
                    alert('Project saved successfully!');
                } else {
                    alert('Error saving project: ' + result.error);
                }
            } catch (error) {
                alert('Network error: ' + error.message);
            }
        }

        async function loadProject() {
            const projectName = prompt('Enter project name to load:');
            if (!projectName) return;
            
            try {
                const response = await fetch(`/load-project/${encodeURIComponent(projectName)}`);
                const projectData = await response.json();
                
                if (projectData.success) {
                    // Load code
                    editor.setValue(projectData.code);
                    
                    // Load board selection
                    if (projectData.selectedBoard) {
                        selectBoard(projectData.selectedBoard);
                    }
                    
                    // Load sensors
                    connectedSensors.clear();
                    if (projectData.connectedSensors) {
                        projectData.connectedSensors.forEach(sensor => {
                            connectedSensors.add(sensor);
                            document.getElementById(`${sensor.replace('gyroscope', 'gyro')}-status`).classList.add('connected');
                        });
                    }
                    
                    // Load 3D scene
                    if (projectData.scene) {
                        loadScene(projectData.scene);
                    }
                    
                    document.getElementById('projectName').value = projectName;
                    alert('Project loaded successfully!');
                } else {
                    alert('Error loading project: ' + projectData.error);
                }
            } catch (error) {
                alert('Network error: ' + error.message);
            }
        }

        function runCode() {
            try {
                const code = editor.getValue();
                eval(code);
                showAIResponse('Code executed successfully!');
            } catch (error) {
                showAIResponse('Runtime error: ' + error.message);
            }
        }

        async function deployProject() {
            const projectData = {
                name: document.getElementById('projectName').value || 'Untitled',
                code: editor.getValue(),
                selectedBoard,
                connectedSensors: Array.from(connectedSensors)
            };
            
            try {
                const response = await fetch('/deploy-project', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(projectData)
                });
                
                const result = await response.json();
                if (result.success) {
                    alert(`Project deployed successfully! URL: ${result.url}`);
                } else {
                    alert('Error deploying project: ' + result.error);
                }
            } catch (error) {
                alert('Network error: ' + error.message);
            }
        }

        function autoSave() {
            const projectData = {
                name: document.getElementById('projectName').value || 'auto_save',
                code: editor.getValue(),
                selectedBoard,
                connectedSensors: Array.from(connectedSensors)
            };
            
            localStorage.setItem('openquantify_autosave', JSON.stringify(projectData));
        }

        function loadAutoSave() {
            const saved = localStorage.getItem('openquantify_autosave');
            if (saved) {
                const projectData = JSON.parse(saved);
                editor.setValue(projectData.code);
                if (projectData.selectedBoard) {
                    selectBoard(projectData.selectedBoard);
                }
                document.getElementById('projectName').value = projectData.name;
            }
        }

        function loadScene(sceneData) {
            // Clear existing meshes
            meshObjects.forEach(mesh => scene.remove(mesh));
            meshObjects = [];
            
            // Load scene from JSON
            try {
                const loader = new THREE.ObjectLoader();
                const loadedScene = loader.parse(sceneData);
                
                // Add objects to current scene
                loadedScene.children.forEach(child => {
                    if (child.isMesh) {
                        scene.add(child);
                        meshObjects.push(child);
                    }
                });
            } catch (error) {
                console.error('Error loading scene:', error);
            }
        }

        // Initialize everything when page loads
        window.addEventListener('load', () => {
            initThreeJS();
            loadAutoSave();
            
            // Add some example meshes
            setTimeout(() => {
                addMesh('cube');
                addMesh('sphere');
            }, 1000);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(600, 400);
        });

        // Add keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 's':
                        event.preventDefault();
                        saveProject();
                        break;
                    case 'o':
                        event.preventDefault();
                        loadProject();
                        break;
                    case 'Enter':
                        if (event.shiftKey) {
                            event.preventDefault();
                            runCode();
                        }
                        break;
                }
            }
        });
    </script>
</body>
</html>